<NAME>
add_difficulty_based_routing
</NAME>
<DESCRIPTION>
Introduce an explicit problem type classification step to guide more tailored routing strategies. For example, problems identified as algebra or geometry might benefit from specialized reasoning primitives or prompts, while number theory or combinatorics might require different approaches. This can help focus computational effort where it's most effective, potentially improving accuracy and efficiency.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # EVOLVE-BLOCK-START
    def forward(self, problem: str) -> Tuple[str, float]:
        """
        Main entry point - routes problem to appropriate primitives.
        This method will be evolved by ShinkaEvolve to discover
        optimal routing strategies.

        Initial baseline: Use baseline_solve (temperature=0.0) which
        exactly matches the adas_aime baseline behavior.
        """
        # Reset tracking for this problem
        self.reset_tracking()

        # Baseline: Exact match to adas_aime (temp=0.0, simple prompt)
        response, cost = self.baseline_solve(problem)
        return response, cost
    # EVOLVE-BLOCK-END
=======
    # EVOLVE-BLOCK-START
    def forward(self, problem: str) -> Tuple[str, float]:
        """
        Route problem based on estimated difficulty and problem type:
        - Use classify_problem_type() to identify problem category.
        - For certain categories, choose specialized reasoning primitives.
        - For example, algebra problems might benefit from python_calc, geometry from deep_think, etc.
        - Combine with difficulty estimate for refined routing.
        """
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Classify problem type
        ptype, type_cost = self.classify_problem_type(problem)
        total_cost += type_cost

        # Step 2: Estimate difficulty
        difficulty, diff_cost = self.estimate_difficulty(problem)
        total_cost += diff_cost

        # Step 3: Routing based on type and difficulty
        if ptype in ["algebra", "number_theory"]:
            if difficulty == "easy":
                response, cost = self.baseline_solve(problem)
            elif difficulty == "medium":
                response, cost = self.deep_think(problem)
                verify_response, verify_cost = self.verify(problem, response)
                response, cost = verify_response, cost + verify_cost
            else:
                response, cost = self.ensemble_vote(problem, n=3)
        elif ptype == "geometry":
            if difficulty != "hard":
                response, cost = self.deep_think(problem)
                verify_response, verify_cost = self.verify(problem, response)
                response, cost = verify_response, cost + verify_cost
            else:
                response, cost = self.ensemble_vote(problem, n=3)
        elif ptype == "combinatorics" or ptype == "calculus":
            response, cost = self.deep_think(problem)
            verify_response, verify_cost = self.verify(problem, response)
            response, cost = verify_response, cost + verify_cost
        else:
            # Default fallback
            response, cost = self.baseline_solve(problem)

        total_cost += cost
        return response, total_cost
    # EVOLVE-BLOCK-END
>>>>>>> REPLACE