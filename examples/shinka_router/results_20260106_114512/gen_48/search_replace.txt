<NAME>
adaptive_difficulty_routing
</NAME>
<DESCRIPTION>
Introduce an explicit problem difficulty classification step to dynamically select reasoning strategies. This allows the agent to allocate resources more efficiently: straightforward problems get quick baseline solutions, while complex problems trigger deeper reasoning and verification cycles. This targeted routing should improve accuracy on harder problems and reduce unnecessary primitive calls on easier ones.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    def forward(self, problem: str) -> Tuple[str, float]:
        """Route problem based on estimated difficulty."""
        self.reset_tracking()
        diff, diff_cost = self.estimate_difficulty(problem)
        total_cost = diff_cost
        if diff == "easy":
            resp, c = self.baseline_solve(problem)
            total_cost += c
        elif diff == "medium":
            resp, c = self.deep_think(problem)
            total_cost += c
            vresp, vc = self.verify(problem, resp)
            total_cost += vc
            resp = vresp
        else:
            resp, c = self.ensemble_vote(problem, n=3)
            total_cost += c
            vresp, vc = self.verify(problem, resp)
            total_cost += vc
            resp = vresp
        return resp, total_cost
=======
    def forward(self, problem: str) -> Tuple[str, float]:
        """Classify difficulty and route accordingly for better accuracy and efficiency."""
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Classify problem difficulty explicitly
        difficulty, c_diff = self.estimate_difficulty(problem)
        total_cost += c_diff

        # Step 2: Route based on difficulty
        if difficulty == "easy":
            # Use fast baseline for simple problems
            resp, c = self.baseline_solve(problem)
            total_cost += c
        elif difficulty == "medium":
            # Use ensemble voting and verification for moderate difficulty
            resp, c = self.ensemble_vote(problem)
            total_cost += c
            vresp, vc = self.verify(problem, resp)
            total_cost += vc
            resp = vresp
        else:
            # For hard problems, apply deep reasoning, critique, and verification
            resp, c = self.deep_think(problem)
            total_cost += c
            crit_resp, c2 = self.self_critique(problem, resp)
            total_cost += c2
            vresp, vc = self.verify(problem, crit_resp)
            total_cost += vc
            resp = vresp

        return resp, total_cost
>>>>>>> REPLACE
</DIFF>