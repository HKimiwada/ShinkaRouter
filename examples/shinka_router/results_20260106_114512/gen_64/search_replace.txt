<NAME>
adaptive_routing_with_self_critique
</NAME>
<DESCRIPTION>
Implement a more nuanced routing strategy that dynamically adjusts the number of deep_think and self_critique iterations based on the estimated difficulty. For "hard" problems, perform multiple deep_think passes, followed by self_critique and verification, to improve correctness. For "medium" problems, do a single deep_think and verify. For "easy" problems, rely on baseline_solve. This approach balances accuracy and efficiency, leveraging self_critique to refine solutions for challenging problems.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    def forward(self, problem: str) -> Tuple[str, float]:
        """
        Main entry point - adaptively route problem based on estimated difficulty.
        """
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Classify problem difficulty
        difficulty, diff_cost = self.estimate_difficulty(problem)
        total_cost += diff_cost

        # Step 2: Route based on difficulty
        if difficulty == "easy":
            # For easy problems, use fast baseline
            response, cost = self.baseline_solve(problem)
        elif difficulty == "medium":
            # For medium problems, do deep_think + verify
            response, cost = self.deep_think(problem)
            v_response, v_cost = self.verify(problem, response)
            response = v_response
            cost += v_cost
        else:
            # For hard problems, attempt ensemble_vote and fallback to deep_think+verify
            response, e_cost = self.ensemble_vote(problem)
            total_cost += e_cost
            # Verify ensemble answer
            v_response, v_cost = self.verify(problem, response)
            response = v_response
            total_cost += v_cost
            total_cost += e_cost

        return response, total_cost
=======
    def forward(self, problem: str) -> Tuple[str, float]:
        """
        Use adaptive multi-stage approach:
        - Easy: baseline_solve
        - Medium: deep_think + verify
        - Hard: multiple deep_think + self_critique + verify
        """
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Estimate difficulty
        difficulty, diff_cost = self.estimate_difficulty(problem)
        total_cost += diff_cost

        if difficulty == "easy":
            # For easy problems, rely on baseline
            response, c = self.baseline_solve(problem)
            total_cost += c
        elif difficulty == "medium":
            # For medium, do one deep_think + verify
            response, c1 = self.deep_think(problem)
            total_cost += c1
            v_response, c2 = self.verify(problem, response)
            total_cost += c2
            response = v_response
        else:
            # For hard, perform multiple deep_think passes, then self_critique, then verify
            draft_response, c1 = self.deep_think(problem)
            total_cost += c1
            for _ in range(2):  # up to 2 self_critique iterations
                critique_response, c3 = self.self_critique(problem, draft_response)
                total_cost += c3
                v_response, c4 = self.verify(problem, critique_response)
                total_cost += c4
                # If verification indicates confidence, break early
                if self.is_response_confident(v_response):
                    response = v_response
                    break
                else:
                    draft_response = critique_response
            else:
                response = critique_response
        return response, total_cost
>>>>>>> REPLACE
</DIFF>