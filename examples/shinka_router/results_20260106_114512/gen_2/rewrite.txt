# EVOLVE-BLOCK-START
def forward(self, problem: str) -> Tuple[str, float]:
    """
    Adaptive routing based on problem difficulty and type.
    Implements a multi-stage decision process:
    1. Classify difficulty
    2. Classify problem type
    3. Route to specialized reasoning pipeline
    4. Verify and refine as needed
    """
    self.reset_tracking()
    total_cost = 0.0

    # Step 1: Classify difficulty
    difficulty, cost_diff = self.estimate_difficulty(problem)
    total_cost += cost_diff

    # Step 2: Classify problem type
    ptype, cost_type = self.classify_problem_type(problem)
    total_cost += cost_type

    # Decide routing based on difficulty
    if difficulty == "easy":
        # For easy problems, attempt direct solve
        response, cost_solve = self.baseline_solve(problem)
        total_cost += cost_solve
        # Verify the answer
        verified_response, cost_verify = self.verify(problem, response)
        total_cost += cost_verify
        # If verification indicates error, fallback to deep_think
        if "incorrect" in verified_response.lower() or "error" in verified_response.lower():
            response, cost_think = self.deep_think(problem)
            total_cost += cost_think
            # Self critique for further refinement
            response, cost_critique = self.self_critique(problem, response)
            total_cost += cost_critique
    elif difficulty == "medium":
        # For medium, use ensemble voting for diversity
        response, cost_vote = self.ensemble_vote(problem, n=3)
        total_cost += cost_vote
        # Verify the ensemble answer
        verified_response, cost_verify = self.verify(problem, response)
        total_cost += cost_verify
        # If verification fails, refine with deep_think + self_critique
        if "incorrect" in verified_response.lower() or "error" in verified_response.lower():
            response, cost_think = self.deep_think(problem)
            total_cost += cost_think
            response, cost_critique = self.self_critique(problem, response)
            total_cost += cost_critique
    else:
        # For hard problems, use deep_think with verification and self-critique
        response, cost_think = self.deep_think(problem)
        total_cost += cost_think
        response, cost_critique = self.self_critique(problem, response)
        total_cost += cost_critique
        # Final verification
        verified_response, cost_verify = self.verify(problem, response)
        total_cost += cost_verify
        # If still uncertain, fallback to ensemble voting
        if "incorrect" in verified_response.lower() or "error" in verified_response.lower():
            response, cost_vote = self.ensemble_vote(problem, n=3)
            total_cost += cost_vote
            verified_response, cost_verify2 = self.verify(problem, response)
            total_cost += cost_verify2

    # Extract final answer in boxed format
    final_answer = self.extract_boxed_answer(verified_response)
    if not final_answer:
        # fallback: use the last response
        final_answer = self.extract_boxed_answer(response) or "000"
    # Format answer as per output spec
    final_response = f"\\boxed{{{final_answer}}}"

    return final_response, total_cost
# EVOLVE-BLOCK-END