"""ShinkaRouter: Improved adaptive routing for AIME with problem classification."""

import re
from typing import Callable, Tuple, List
from collections import Counter

class Agent:
    def __init__(
        self,
        query_llm: Callable,
        quick_temp: float = 0.7,
        deep_temp: float = 0.0,
        verify_temp: float = 0.0,
        ensemble_size: int = 3,
    ):
        self.query_llm = query_llm
        self.quick_temp = quick_temp
        self.deep_temp = deep_temp
        self.verify_temp = verify_temp
        self.ensemble_size = ensemble_size
        self._calls = []
        self.output_format = (
            "On the final line output only the digits of the answer (0-999). "
            "Provide your final answer enclosed in a \\boxed{{...}}."
        )

    def _track(self, name): self._calls.append(name)
    def get_calls(self): return self._calls.copy()
    def reset(self): self._calls.clear()

    @staticmethod
    def _extract_boxed(response: str) -> str:
        idx = response.rfind("\\boxed")
        if idx < 0: idx = response.rfind("\\fbox")
        if idx < 0: return ""
        start = response.find("{", idx)
        if start < 0: return ""
        level = 0
        for i in range(start, len(response)):
            if response[i] == "{": level += 1
            elif response[i] == "}":
                level -= 1
                if level == 0:
                    content = response[start+1:i]
                    return content.strip().lstrip("0") or "0"
        return ""

    # Primitive implementations with uniform prompt style
    def baseline_solve(self, problem):
        self._track("baseline")
        prompt = f"{self.output_format}\n\n{problem}\n\n"
        return self.query_llm(prompt=prompt, system="You are a skilled mathematician.", temperature=0.0)
    def quick_solve(self, problem):
        self._track("quick")
        prompt = f"{self.output_format}\n\n{problem}\n\n"
        return self.query_llm(prompt=prompt, system="You are a skilled mathematician.", temperature=self.quick_temp)
    def deep_think(self, problem):
        self._track("deep")
        prompt = f"{self.output_format}\n\nSolve carefully:\n\n{problem}"
        return self.query_llm(prompt=prompt, system="You are an expert mathematician. Think step-by-step.", temperature=self.deep_temp)
    def verify(self, problem, response):
        self._track("verify")
        prompt = f"{self.output_format}\n\nProblem: {problem}\n\nSolution:\n{response}\n\nVerify carefully."
        sys = "You are a rigorous professor."
        return self.query_llm(prompt=prompt, system=sys, temperature=self.verify_temp)
    def ensemble_vote(self, problem):
        self._track("ensemble")
        responses = []
        total_cost = 0
        for _ in range(self.ensemble_size):
            resp, c = self.query_llm(
                prompt=f"{self.output_format}\n\n{problem}\n\n",
                system="You are a skilled mathematician.",
                temperature=0.5
            )
            responses.append((resp, c))
            total_cost += c
        answers = [self._extract_boxed(r[0]) for r in responses if self._extract_boxed(r[0])]
        if answers:
            count = Counter(answers)
            winner, _ = count.most_common(1)[0]
            for r, c in responses:
                if self._extract_boxed(r[0]) == winner:
                    return r[0], total_cost
        return responses[0][0], total_cost
    def self_critique(self, problem, draft):
        self._track("critique")
        prompt = f"{self.output_format}\n\nProblem: {problem}\n\nDraft:\n{draft}\n\nReview and improve."
        return self.query_llm(prompt=prompt, system="You review your work.", temperature=self.deep_temp)
    def estimate_type(self, problem):
        self._track("type")
        prompt = f"Classify this problem as algebra, geometry, number_theory, or combinatorics."
        resp, c = self.query_llm(prompt=prompt, system="Categorizer", temperature=0.0)
        t = resp.strip().lower().replace(" ","_")
        for cat in ["algebra","geometry","number_theory","combinatorics"]:
            if cat in t: return cat, c
        return "algebra", c

    def forward(self, problem):
        self.reset()
        total=0
        # Step 1: classify problem type
        ptype, c_type = self.estimate_type(problem)
        total += c_type
        # Step 2: estimate difficulty
        diff, c_diff = self.estimate_difficulty(problem)
        total += c_diff

        # Routing based on type and diff
        if diff=="easy":
            resp, c_resp = self.quick_solve(problem)
            total+=c_resp
            resp, c_v = self.verify(problem, resp)
            total+=c_v
        elif diff=="medium":
            resp, c = self.deep_think(problem)
            total += c
            vresp, c_v = self.verify(problem, resp)
            total += c_v
            # Optional critique
            if vresp != resp:
                crit, c_c = self.self_critique(problem, resp)
                total+=c_c
                vresp2, c_v2 = self.verify(problem, crit)
                total+=c_v2
                resp = vresp2
            else:
                resp = vresp
        else:
            resp, c = self.ensemble_vote(problem)
            total+=c
            vresp, c_v= self.verify(problem, resp)
            total+=c_v
            if vresp != resp:
                crit, c_c= self.self_critique(problem, resp)
                total+=c_c
                vresp2, c_v2= self.verify(problem, crit)
                total+=c_v2
                resp= vresp2
            else:
                resp= vresp
        return resp, total