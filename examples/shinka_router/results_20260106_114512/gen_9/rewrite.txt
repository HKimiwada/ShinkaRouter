# The new parametric algorithm implementation here.
# It dynamically routes problems based on estimated difficulty,
# using deeper reasoning for harder problems and faster solves for easier ones.
# It also tracks calls to stay within constraints, aiming for better accuracy.
# The approach improves on the original static baseline.

# EVOLVE-BLOCK-START
def forward(self, problem: str) -> Tuple[str, float]:
    self.reset_tracking()
    total_cost = 0.0

    # Step 1: Estimate difficulty to guide routing
    difficulty, diff_cost = self.estimate_difficulty(problem)
    total_cost += diff_cost

    if difficulty == "easy":
        # For easy problems, use quick_solve
        response, cost = self.quick_solve(problem)
        total_cost += cost
        return response, total_cost

    elif difficulty == "medium":
        # For medium problems, use deep_think followed by verify
        response, response_cost = self.deep_think(problem)
        total_cost += response_cost
        verify_response, verify_cost = self.verify(problem, response)
        total_cost += verify_cost
        return verify_response, total_cost

    else:
        # For hard problems, use ensemble_vote to get diversity
        response, cost = self.ensemble_vote(problem, n=3)
        total_cost += cost
        return response, total_cost
# EVOLVE-BLOCK-END