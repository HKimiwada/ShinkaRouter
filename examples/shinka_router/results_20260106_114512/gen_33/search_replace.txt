<NAME>
add_confidence_threshold_routing
</NAME>
<DESCRIPTION>
The previous attempt to improve routing by adding confidence thresholds did not match the exact search pattern, likely due to indentation or formatting differences. To fix this, I will insert a simplified, robust version of the confidence-based routing directly within the existing `forward` method, matching the exact line starting with `def forward(self, problem: str) -> Tuple[str, float]:`. This will include a straightforward confidence check based on a secondary call to `ensemble_vote` with a larger sample size, and then decide whether to use the primitive routing or fallback to a conservative primitive like baseline_solve. This approach balances complexity and correctness.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
def forward(self, problem: str) -> Tuple[str, float]:
        """
        Main entry point - routes problem to appropriate primitives.
        This method will be evolved by ShinkaEvolve to discover
        optimal routing strategies.

        Initial baseline: Use baseline_solve (temperature=0.0) which
        exactly matches the adas_aime baseline behavior.
        """
        # Reset tracking for this problem
        self.reset_tracking()

        # Baseline: Exact match to adas_aime (temp=0.0, simple prompt)
        response, cost = self.baseline_solve(problem)
        return response, cost
=======
def forward(self, problem: str) -> Tuple[str, float]:
        """
        Main entry point - routes problem to appropriate primitives.
        This method will be evolved by ShinkaEvolve to discover
        optimal routing strategies.
        """
        # Reset tracking for this problem
        self.reset_tracking()

        # Use a high-confidence check: run ensemble_vote with n=5
        # and check if the top answer has at least 3 votes
        resp, c = self.query_llm(
            prompt=f"{self.output_format}\n\n{problem}\n\n",
            system="You are a skilled mathematician.",
            temperature=0.5,
        )
        # Run ensemble_vote again with n=5 to get votes
        votes_response, votes_cost = self.query_llm(
            prompt=f"{self.output_format}\n\n{problem}\n\n",
            system="You are a skilled mathematician.",
            temperature=0.5,
        )
        # Count votes
        answers = []
        for _ in range(5):
            r, _ = self.query_llm(
                prompt=f"{self.output_format}\n\n{problem}\n\n",
                system="You are a skilled mathematician.",
                temperature=0.5,
            )
            ans = self.extract_boxed_answer(r)
            if ans:
                answers.append(ans)
        count = Counter(answers)
        top_votes = count.most_common(1)[0][1] if answers else 0

        # Decide routing based on confidence
        if top_votes >= 3:
            # High confidence, use ensemble_vote primitive
            # Actually, run the ensemble_vote primitive
            resp, c = self.ensemble_vote(problem, n=5)
            total_cost = c
            # Verify the answer
            vresp, vc = self.verify(problem, resp)
            total_cost += vc
            return vresp, total_cost
        else:
            # Low confidence, fallback to baseline
            resp, c = self.baseline_solve(problem)
            total_cost = c
            return resp, total_cost
>>>>>>> REPLACE
</DIFF>