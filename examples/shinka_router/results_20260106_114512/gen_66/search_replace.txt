<NAME>
add_difficulty_weighted_routing
</NAME>
<DESCRIPTION>
This modification introduces a weighted routing decision that accounts for estimated problem difficulty and type, aiming to allocate more resources (more extensive reasoning, verification, self-critique) to complex or less familiar categories. By guiding the program to apply more rigorous steps selectively, it can improve accuracy especially on harder problems, while avoiding unnecessary resource expenditure on easier ones. This approach leverages the existing classification primitives, but refines the routing by dynamically adjusting the depth of reasoning according to weighted importance, thus balancing accuracy with efficiency.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    def forward(self, problem: str) -> Tuple[str, float]:
        self.reset_tracking()
        total_cost = 0.0
        # Step 1: Estimate difficulty
        difficulty, cost_diff = self.estimate_difficulty(problem)
        total_cost += cost_diff
        # Step 2: Route based on difficulty
        if difficulty == "easy":
            resp, c = self.baseline_solve(problem)
            total_cost += c
        elif difficulty == "medium":
            resp, c = self.deep_think(problem)
            total_cost += c
            ver_resp, c2 = self.verify(problem, resp)
            total_cost += c2
            resp = ver_resp
        else:  # hard
            resp, c = self.deep_think(problem)
            total_cost += c
            crit_resp, c2 = self.self_critique(problem, resp)
            total_cost += c2
            ver_resp, c3 = self.verify(problem, crit_resp)
            total_cost += c3
            resp = ver_resp
        return resp, total_cost
=======
    def forward(self, problem: str) -> Tuple[str, float]:
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Classify problem type and difficulty
        p_type, c_type = self.classify_problem_type(problem)
        diff, c_diff = self.estimate_difficulty(problem)

        total_cost += c_type + c_diff

        # Determine resource allocation multiplier based on difficulty and type
        # Assign higher weight to 'hard' and 'number_theory'/'geometry' types
        weight = 1.0
        if diff == "hard":
            weight += 1.0
        if p_type in ["number_theory", "geometry"]:
            weight += 0.5
        # For easier or familiar types, decrease resource allocation
        elif diff == "easy" or p_type == "algebra":
            weight -= 0.3

        # Clamp weight between 0.5 and 2.0 for stability
        weight = max(0.5, min(2.0, weight))

        # Use weighted reasoning
        if weight >= 1.5:
            # More resource intensive, e.g., for hard/uncertain problems
            resp, c = self.deep_think(problem)
            total_cost += c
            # Self-critique and verification for more accuracy
            crit_resp, c2 = self.self_critique(problem, resp)
            total_cost += c2
            ver_resp, c3 = self.verify(problem, crit_resp)
            total_cost += c3
            resp = ver_resp
        elif weight >= 1.0:
            # Moderate reasoning
            resp, c = self.deep_think(problem)
            total_cost += c
            ver_resp, c2 = self.verify(problem, resp)
            total_cost += c2
            resp = ver_resp
        else:
            # Less resource, simpler path
            resp, c = self.baseline_solve(problem)
            total_cost += c

        return resp, total_cost
>>>>>>> REPLACE