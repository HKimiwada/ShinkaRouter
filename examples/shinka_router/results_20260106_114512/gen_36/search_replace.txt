<NAME>
adopt_answer_verification_pipeline
</NAME>
<DESCRIPTION>
The current routing relies on estimating difficulty and then choosing primitive strategies accordingly, but the final answer extraction and verification are not maximally robust. I propose to implement a structured answer verification pipeline, which first extracts the tentative answer from initial primitives (like baseline or deep_think), then applies a dedicated answer verification primitive that re-queries with the extracted answer, validating correctness systematically before returning. This aims to reduce false positives and improve accuracy, especially with complex problems requiring multiple reasoning steps, aligning with expert practices for solving challenging math problems reliably.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-END
=======
# Enhanced final answer verification pipeline for improved correctness and robustness
def forward(self, problem: str) -> Tuple[str, float]:
    """Route problem using answer extraction + dedicated verification to maximize correctness."""
    self.reset_tracking()
    total_cost = 0.0

    # Step 1: Estimate difficulty for initial primitive choice
    difficulty, diff_c = self.estimate_difficulty(problem)
    total_cost += diff_c

    # Step 2: Generate initial solution based on difficulty level
    if difficulty == "easy":
        resp, c1 = self.base_solve_with_answer_extraction(problem)
        total_cost += c1
    elif difficulty == "medium":
        resp, c1 = self.deep_think_with_answer_extraction(problem)
        total_cost += c1
    else:
        resp, c1 = self.ensemble_vote_with_answer_extraction(problem)
        total_cost += c1

    # Step 3: Extract answer from the response
    candidate_answer, c2 = self.extract_answer_response(resp)
    total_cost += c2

    # Step 4: Verify the extracted answer with a dedicated verification primitive
    verify_response, c3 = self.verify(problem, resp)
    total_cost += c3

    # Step 5: Extract verification answer
    verified_answer, c4 = self.extract_answer_response(verify_response)
    total_cost += c4

    # Step 6: Check if verification answer matches candidate answer
    if verified_answer == candidate_answer and verified_answer is not None:
        # Accept the verified answer
        # Format to final boxed answer
        final_response = f"\\boxed{{{verified_answer}}}"
        return final_response, total_cost
    else:
        # Fallback: Use the initial candidate answer if verification failed
        final_response = f"\\boxed{{{candidate_answer if candidate_answer else '0'}}}"
        return final_response, total_cost

# Auxiliary methods to incorporate into class
def base_solve_with_answer_extraction(self, problem: str) -> Tuple[str, float]:
    response, c = self.baseline_solve(problem)
    return response, c

def deep_think_with_answer_extraction(self, problem: str) -> Tuple[str, float]:
    response, c = self.deep_think(problem)
    return response, c

def ensemble_vote_with_answer_extraction(self, problem: str) -> Tuple[str, float]:
    response, c = self.ensemble_vote(problem, n=3)
    return response, c

def extract_answer_response(self, response: str) -> Tuple[Optional[str], float]:
    """Extract answer and track cost."""
    cost = 0.0
    ans = self.extract_boxed_answer(response)
    return ans, cost
>>>>>>> REPLACE