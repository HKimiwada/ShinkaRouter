<NAME>
strategy_based_on_problem_type
</NAME>
<DESCRIPTION>
This enhancement introduces a preliminary step in the routing process: classify the problem type (e.g., algebra, geometry, number theory) before deciding on the solution strategy. Based on the problem type, select primitives optimized for that category— for example, using deep_think with more detailed prompts for geometry problems while relying on the baseline_solve for algebra problems. This targeted routing can improve accuracy by aligning the primitive use with the problem’s nature, thus reducing unnecessary calls and higher-error-prone approaches on simpler problems.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    def forward(self, problem: str) -> Tuple[str, float]:
        """
        Route problem based on estimated difficulty:
        - easy: baseline_solve (1 call)
        - medium: deep_think + verify (2 calls)
        - hard: ensemble_vote (3 calls)
        """
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Estimate difficulty
        difficulty, diff_cost = self.estimate_difficulty(problem)
        total_cost += diff_cost
=======
    def forward(self, problem: str) -> Tuple[str, float]:
        """
        Route problem based on problem type:
        - algebra: use baseline_solve (1 call)
        - geometry: use deep_think with detailed reasoning (2 calls) + verify
        - number_theory or combinatorics: ensemble_vote (3 calls)
        - others: fallback to deep_think + verify
        """
        self.reset_tracking()
        total_cost = 0.0

        # Step 1: Classify problem type
        p_type, type_cost = self.classify_problem_type(problem)
        total_cost += type_cost

        # Step 2: Route based on type
        if p_type == "algebra":
            # Simple, straightforward solve
            response, c = self.baseline_solve(problem)
            total_cost += c
            return response, total_cost
        elif p_type == "geometry":
            # Geometry might benefit from detailed reasoning
            response, c = self.deep_think(problem)
            total_cost += c
            verify_response, verify_c = self.verify(problem, response)
            total_cost += verify_c
            return verify_response, total_cost
        elif p_type in ["number_theory", "combinatorics"]:
            # Use ensemble for these problem types
            response, c = self.ensemble_vote(problem, n=3)
            total_cost += c
            return response, total_cost
        else:
            # Fallback for other types
            response, c = self.deep_think(problem)
            total_cost += c
            verify_response, verify_c = self.verify(problem, response)
            total_cost += verify_c
            return verify_response, total_cost
>>>>>>> REPLACE
</DIFF>