# The structurally redesigned program here.
# EVOLVE-BLOCK-START
def forward(self, problem: str) -> Tuple[str, float]:
    """
    Adaptive multi-stage routing:
    1. Classify problem difficulty and type.
    2. Route to simple, intermediate, or complex reasoning primitives.
    3. Use verification and self-critique selectively.
    4. Aim to maximize accuracy while controlling calls.
    """
    self.reset_tracking()
    total_cost = 0.0

    # Step 1: Classify difficulty
    difficulty, cost_diff = self.estimate_difficulty(problem)
    total_cost += cost_diff

    # Step 2: Classify problem type
    ptype, cost_type = self.classify_problem_type(problem)
    total_cost += cost_type

    # Decide routing based on difficulty
    if difficulty == "easy":
        # For easy problems, use baseline_solve (fast, low calls)
        response, cost_resp = self.baseline_solve(problem)
        total_cost += cost_resp
        # Optional verification for confidence
        response, verify_cost = self.verify(problem, response)
        total_cost += verify_cost
    elif difficulty == "medium":
        # For medium problems, use deep_think + verify
        response, cost_think = self.deep_think(problem)
        total_cost += cost_think
        # Self-critique for refinement
        response, critique_cost = self.self_critique(problem, response)
        total_cost += critique_cost
        # Final verification
        response, verify_cost = self.verify(problem, response)
        total_cost += verify_cost
    else:
        # For hard problems, ensemble + self critique
        response, cost_ensemble = self.ensemble_vote(problem, n=3)
        total_cost += cost_ensemble
        # Self critique for refinement
        response, critique_cost = self.self_critique(problem, response)
        total_cost += critique_cost
        # Final verification
        response, verify_cost = self.verify(problem, response)
        total_cost += verify_cost

    # Extract answer in correct format
    answer = self.extract_boxed_answer(response)
    if answer is None:
        # fallback: use deep_think as last resort
        response, cost_last = self.deep_think(problem)
        total_cost += cost_last
        answer = self.extract_boxed_answer(response)
        if answer is None:
            # fallback: use baseline_solve
            response, cost_fb = self.baseline_solve(problem)
            total_cost += cost_fb
            answer = self.extract_boxed_answer(response)
            if answer is None:
                # default to '000'
                answer = "000"
    # Format answer in boxed
    final_response = f"\\boxed{{{answer}}}"
    return final_response, total_cost
# EVOLVE-BLOCK-END