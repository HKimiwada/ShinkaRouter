# EVOLVE-BLOCK-START
def forward(self, problem: str) -> Tuple[str, float]:
    self.reset_tracking()
    total_cost = 0.0
    
    # Step 1: Initial attempt with quick_solve (fast, cheap)
    resp, cost = self.quick_solve(problem)
    total_cost += cost
    
    # Step 2: Extract answer and verify
    candidate_answer = self.extract_boxed_answer(resp)
    if candidate_answer:
        verif_resp, verif_cost = self.verify(problem, resp)
        total_cost += verif_cost
        if verif_resp.strip().lower().startswith("yes") or "correct" in verif_resp.lower() or "final answer" in verif_resp.lower():
            # Trust verification if it confirms correctness
            return resp, total_cost
        else:
            # If verification indicates errors, proceed to deeper reasoning
            # Step 3: Use deep_think for detailed reasoning
            reasoning_resp, reason_cost = self.deep_think(problem)
            total_cost += reason_cost

            # Step 4: Verify again
            revised_resp, rev_cost = self.verify(problem, reasoning_resp)
            total_cost += rev_cost

            # Prefer revised response if verification is positive
            # Else fallback to previous if verification indicates correctness
            # For simplicity, accept the latest if verification is positive
            if revised_resp.strip().lower().startswith("yes") or "correct" in revised_resp.lower():
                return reasoning_resp, total_cost
            else:
                # Final fallback: accept the best attempt (initial quick + verification)
                return resp, total_cost
    else:
        # No answer extracted: go deeper
        reasoning_resp, reason_cost = self.deep_think(problem)
        total_cost += reason_cost
        # Final verification
        final_resp, final_cost = self.verify(problem, reasoning_resp)
        total_cost += final_cost
        return final_resp, total_cost
# EVOLVE-BLOCK-END